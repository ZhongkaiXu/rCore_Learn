# 堆

内核申请了一大块空间（物理内存上），实现了rustc要求的trait，于是编译器可以自动将这段空间作为堆，使用Vec等容器。

# 地址空间

内核把剩下的物理内存划分成页，对于每个app，内核在堆上申请一段空间，作为该应用的页表。将app的可执行文件，以页为单位复制到物理内存的页上，并且在app的页表中记录映射关系。

这个拷贝的过程中，是直接访问物理地址的，因为内核属于裸机，当它在对内存访问的时候，不涉及分页，或者设置内核的地址空间只是为了不让其他应用访问内核，而内核理论上可以直接访问任何地址。（不知道这样理解对不对）

在应用程序编译生成可执行文件的过程中，所有和地址相关的值，都是一个相对于linker.ld中规定的起始地址的值，也就是一个虚拟地址。

当应用程序在内核上执行，进入用户态之前，内核会把这个app的页表相关信息（root-ppn）通过satp传递给MMU，MMU会通过satp的内容，按三级页表的规则将虚拟地址转换成物理地址，对物理内存进行访问。（这是属于riscv架构下硬件的设计规则和内核的开发标准？）

如果是内核要访问某个物理地址，在内核的地址空间下，satp的MODE字段应该为0，也就是内核中和地址相关的值无需经过MMU的转换。

如果内核和应用程序有交互，应用程序传递给内存一个指针，那么这个指针是不能直接使用的，在内核的地址空间下，内核应该先把这个地址转换成对应的物理地址，然后内核直接访问这个地址就好了。
